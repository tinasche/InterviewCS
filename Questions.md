# CSharp Interview questions and answers
[Github repo](https://github.com/tinasche/InterviewCS) for this content.
## Part 1: Basics

1. What is a class? What is a sealed class? What is a partial class?
A class is a **template** for creating objects.
```
sealed class A 
{
    public int Id { get; set; } = default;
    public string Name { get; set; } = String.empty;

    public void GetName()
    {
        return this.Name;
    }
}
```
A sealed class is a class with the *sealed* keyword used to restrict a class from being inherited from. __`Recommend to use if classes are not to have subtypes.`__
A partial class is a class with the *partial* keyword used to split a class into multiple files. At runtime the files are organised as one file so method and variable names must be unique across the partial class files.

2. List and briefly explain the main principles of object-oriented programming?
<br/>**Abstraction**: A technique used to provide methods of interacting with a component without revealing the inner-workings of said component. 
<br/>**Polymorphism**: The ability of an object/type to take multiple forms. Compile-time (method overloading) and run-time (method overriding) polymorphism .
<br/>**Inheritance**: The ability of a type to attain the attributes of another type. 
<br/>**Encapsulation**: A technique of grouping related members of a type together.

3. What is an interface? A form of abstract class with **only** abstract members i.e., no method definition or property instantiation. It enforces the classes which *implement* the interface to define the members described therein.

4. Define a constructor and its types. Define a destructor.
<br/>A constructor is a method that is used to instantiate the state of an object defined using the *new* keyword. The types of constructors are: default (auto-generated by the runtime), static (instantiate static members), parameterised (default constructor with parameters).
<br/>A destructor is a method that cleans up memory by triggering garbage collection on its type. Also known as a Finalizer.

5. Briefly describe the C# Common Type System.
<br/>Every variable, constant and expression that evaluates to some value has a type. Information contained in a type may include:
- the base type is inherits from
- the interface it implements
- the maximum and minimum values it can represent
- the members (methods, fields, events e.t.c)
- the storage space that a variable of the type requires
since types are static at compile time, type conversion is necessary. Types of conversions include: implicit, explicit, user-defined and conversion with helper classes.
<br/>All types inherit from the *System.Object* type. Types are either 
<br/>a. Value types (have direct access to values) are sealed. Value types in C# are byte, int, long, boolean, float, char, decimal and double as enum and/or struct types. Built-in numeric types are structs which have fields and methods you can access. This also means you can use the `struct` to create your custom value types. Default value for numeric types is 0.
<br/>b. Reference types (have a memory location for values). A type that is defined as class, record, delegate, array or interface is a reference type.  
You can use *enum, struct, interface or class* constructs to create custom types for your applications. Default value for reference types is null.

6. What is a virtual method and how is it different from an abstract method?
<br/>A virtual method is a method that uses the *virtual* keyword which denotes that it can be overriden by a derived class implementation. It *must* have a default implementation.
<br/>An abstract method is a method that uses the *abstract* keyword to describe a method signature. It is contained within an abstract class and must be implemented by a class which inherits from it.

7. What is boxing and unboxing? The conversion of a type from value to reference is called boxing. The conversion of a type from reference to value is called unboxing. 

8. What is a delegate?

9. Describe the access modifiers in CSharp.
C# has four main access modifiers: public, private, protected and internal. These four can be used in combination to construct 6 access modifier parameters:
- public: access is not restricted
- protected: access is restricted within the containing type or its subtypes 
- internal: access is restricted within the current assembly
- protected internal: access is restricted within the current assembly or subtypes of the containing type
- private: access is limited within the containing member.
- private protected: access is limited to the current type of subtypes within the same assembly

10. What is an array?
An array is a variable to store multiple elements under the same identifier. Arrays can be single, multi-dimensional or jagged. The default value for numeric types is zero and for reference types is null. Array types are reference types derived from the `Array` base type which in turn implements the `IEnumerable` and `IEnumerable<T>` allows for foreach iteration. The length and dimensions of an array are established when the array is created and cannot be changed in te lifetimeof that array. Basic usage of array below where T is the type of  elements to store in the array:
```
// Declare with element count
T[] identifier = new T[5];

// Declare with initial elements
T[] identifier = new T[] { item1, item2, ..., itemN};

// Shorthand syntax
T[] identifier = { item1, item2, ..., itemN};

// Implicit typed array with new operator
var identifier = new[] { item1, item2, ..., itemN};

// Multi-dimensional array: x and y are dimensions for the array
T[,] identifier = new T[x,y];

// Jaggered array
T[][] identifier = new T[x][y];


```
11. What is LINQ?
LINQ (Language INtegrated Query) is the name for query technologies intergrated into the C# language. Use a query expression (a query expressed in query syntax) written either in a) query syntax or b) method syntax. A basic example of LINQ is shown below:
```
int[] numbers = { 1, 3, 45, 30, 890 };

// LINQ expression: number is the range variable
IEnumerable aboveFifty = from number in numbers
                        where number > 50
                        select number;

// Iterate through the query variable
foreach (var num in aboveFifty)
{
    Console.WriteLine(num);
}
```
Query expressions can be used to query and transform data from any LINQ-enabled data source. A query is not evaluated until you iterate over the query variable (stores the query instead of the results of the query as an enumerable). A query expression must begin with the `from` clause (introduces the data source) and ends with either `select` or `group` clause. In between it can contain multiple optional clauses such as `where`, `orderby`, `join`, `let` or other `from` clauses.  
__`Recommend to use query syntax to method syntax unless necessary.`__

12. What is Reflection?
13. Describe the CLR and .NET architecture.
14. Describe Dependency Injection.
15. What are expression trees?
16. Demonstrate your knowledge of regular expressions in C#.
17. Explain code compilation in C#.
18. Demonstrate your knowledge of deconstruction of types.
19. Briefly describe the Interface type.
20. Describe the record type in C#.
21. What is Serialisation in C#?
22. Explain Events in C#.
23. Explain the concepts of Covariance and Contravariance.
24. Briefly describe how indexers work in C#.
Indexers allows class/struct instances to be indexed in much the same way as with arrays. They are a syntactic convenience, using [] array notation to get/set attributes of the object in the same manner as with arrays. The signature of an indexer consists of the number and types of its formal parameters. Parameter types for indexers are open to any valid type. Below is sample code using expressing bodies to define the work of indexers.
```
public class Indexmate<T>
    {
        private T[] arr = new T[100];

        // Indexer with get and set accessors
        public T this[int i] 
        {
            // Show alternative full syntax vs expression body syntax
            // get { return arr[i]; }
            get => arr[i];
            // set { arr[i] = value; }
            set => arr[i] = value;
        }

        // Indexer with only a get accessor
        public T this[int i] => arr[i];
        
        // Indexer with only a set accessor
        public T this[int i] => arr[i] = value;

}
// Use object with [] syntax
var firstIndexer = new Indexmate<string>();
firstIndexer[0] = "tinashe";
```